---
title: "Workshop MOD: Visualisation de données omiques avec R"
---

# Introduction 

# Données

Les données qu'on utilisera dans ce Workshop se trouvent dans la librairie *OmicCircos* de R.
Elles se basent sur des bases de données fournies par ***The Cancer Genome Atlas Program*** (TCGA). On s'intéresse aux données des patients diagnostiqués d'un cancer du sein. Voici la liste des tableaux utilisés :

* TCGA.BC.cnv.2k.60 : Les variables dans ce tableau sont respectivement le chromosome, sa position et le nom du gène observé et les 60 autres variables représentent 60 individus différents.

* TCGA.BC.fus : Ce tableau représente la fusion des deux gènes qui a eu place pour un individu préci.

![Extrait du tableau fus](./images/tableau%20fus.png)

* TCGA.BC.gene.exp.2k.60 : Sur 60 individus, on étudie une métrique en rapport avec l'expression du gène. Le chromosome, sa position et le nom du gène observé sont notés.

* TCGA.BC.sample60 : On indique ici pour 60 cas quel type de cancer du sein le patient en souffre : LumA, LumB, Basal ou Her2.

* TCGA.BC_Her2_cnv_exp : Dans ce tableau, des tests statistiques sont effectués et on récupère la *t-value* et la *p-value*. On note les métriques FDR et Bonferroni de plus.

* TCGA.PAM50_genefu_hg18 : Il s'agit alors d'un ensemble de 50 gènes qui ont été identifiés comme une signature d'expression génique associée aux sous-types du cancer du sein (LumA, LumB, Basal, Her2 ou Normal) en fonction des schémas d'expression génique.


![Extrait du tableau CNV](./images/Extrait%20PAM50.png)


# Recueillir les données

Afin de pouvoir mettre en oeuvre les différentes méthodes de visualisation, il nous faut tout d'abord recueillir les données et les travailler.

Pour cela, suivez les étapes présentées ci-dessous :

-   Etape 1 : Chargement de la librairie "Omiccircos"

```{r}
library(OmicCircos)
```

-   Etape 2 : Importation des données

```{r}
data("TCGA.PAM50_genefu_hg18")
data("TCGA.BC.fus")
data("TCGA.BC.cnv.2k.60")
data("TCGA.BC.gene.exp.2k.60")
data("TCGA.BC.sample60")
data("TCGA.BC_Her2_cnv_exp")
```

-   Etape 3 : Mise en forme des données

```{r}
Her2.i = which(TCGA.BC.sample60[,2] == "Her2")
Her2.n = TCGA.BC.sample60[Her2.i,1]
Her2.j = which(colnames(TCGA.BC.cnv.2k.60)%in%Her2.n)
cnv = TCGA.BC.cnv.2k.60[,c(1:3,Her2.j)]

cnv.m = cnv[,c(4:ncol(cnv))]
cnv.m[cnv.m > 2] = 2
cnv.m[cnv.m < -2] = -2
cnv = cbind(cnv[,1:3], cnv.m)

Her2.j = which(colnames(TCGA.BC.gene.exp.2k.60)%in% Her2.n)

gene.exp = TCGA.BC.gene.exp.2k.60[,c(1:3,Her2.j)]
``` 

# Visualisations classiques

L'ensemble des visualisations ci-dessous s'appuient sur la base de données *TCGA.PAM50_genefu_hg18*.

```{r, include=FALSE}
#|echo: false
#|output: false
#|warning: false

# chargement des packages nécessaires
library(ggplot2)
library(dplyr)
library(viridis)
library(viridisLite)
library(hrbrthemes)

# chargement des données
data("TCGA.PAM50_genefu_hg18")
```
### Comparaison de Deux Densités

Commençons par étudier quelques densités des types de cancer. Voici un exemple très basique de visualisation graphique de la **comparaison des densités des types de cancer *LumA* et *LumB*** :

```{r}
# création de la base de données
data <- data.frame(value = c(TCGA.PAM50_genefu_hg18$LumA,
                            TCGA.PAM50_genefu_hg18$LumB),
                   type = c(rep("LumA", 50),
                            rep("LumB", 50)))

# création du graphe
comparaison <- data %>%
    ggplot(aes(x=value, fill=type)) +
    geom_density()

# affichage du graphe
print(comparaison)
```

::: {.callout-important appearance="simple"}
L'utilisation de *ggplot* nécessite la création d'une base de données contenant les variables utiles pour le graphe.
:::

::: {.callout-note appearance="simple"}
## %>%
Cet opérateur est un pipe, fréquemment représenté par une barre verticale ‘|’ : il renvoie la sortie d’une commande vers l’entrée d’une autre.
:::

De nombreuses options de *ggplot* peuvent améliorer l'apparence générale de ce graphe telles que ci-dessous.

```{r}
# création du graphe
comparaison <- data %>%
  ggplot(aes(x=value, fill=type)) +
  geom_density(aes(color=type), alpha=0.4) +
  scale_color_manual(values = c("darkblue", "pink")) +
  scale_fill_manual(values = c("darkblue", "pink")) +
  theme(strip.text.x = element_text(size = 8),
        plot.title = element_text(hjust = 0.5, face="bold")) +
  xlab("Value") +
  ylab("Density") +
  guides(color = "none") +
  labs(title = "Density Comparaison of Cancer Types Gene Occurrence",
       fill = "Cancer Type")

# affichage du graphe
print(comparaison)
```

Il est également possible de représenter les densités sur deux graphes différents plutôt que de les superposer.

```{r}
# création du graphe
comparaison <- data %>%
  ggplot(aes(x=value, fill=type)) +
  geom_density(aes(color=type), alpha=0.4) +
  scale_color_manual(values = c("darkblue", "pink")) +
  scale_fill_manual(values = c("darkblue", "pink")) +
  theme(strip.text.x = element_text(size = 8),
        plot.title = element_text(hjust = 0.5, face="bold")) +
  xlab("Value") +
  ylab("Density") +
  facet_wrap(~type, scales = "fixed")+
  guides(color = "none") +
  labs(title = "Density Comparaison of Cancer Types Gene Occurrence",
       fill = "Cancer Type")

# affichage du graphe
print(comparaison)
```

::: {.callout-tip appearance="simple"}
## Utilisation de *facet_wrap*
Les échelles des différents graphiques peuvent être formatées différemment à l'aide de l'option *scales* :
*"fixed"* permet d'obtenir des échelles égales pour tous les graphes mais d'autres options telles que *"free_x"*, *"free_y"* ou *"free"* sont envisageables.
:::

Le cancer de type *Her2* est le type de cancer le plus courant parmi tous ceux présents dans la base de données support.

**En vous appuyant sur l'exemple précédent, représentez graphiquement la comparaison des densités d'une personne atteinte d'un cancer de type *Her2* et d'une personne saine.**

::: {.callout-tip appearance="simple"}
Les données d'une personne saine sont contenues dans la variable *Normal* de la base de données.
:::

Par la suite, les couleurs utilisées pour la représentation de *Her2* et *Normal* seront respectivement *darkred* et *darksalmon*.

```{r}
#| code-fold: true
#| code-summary: "Afficher la Solution"
#| output: false

# création de la base de données
data <- data.frame(value = c(TCGA.PAM50_genefu_hg18$Her2,
                            TCGA.PAM50_genefu_hg18$Normal),
                   type = c(rep("Her2", 50),
                            rep("Normal", 50)))

# création du graphe
comparaison <- data %>%
  ggplot(aes(x=value, fill=type)) +
  geom_density(aes(color=type), alpha=0.4) +
  scale_color_manual(values = c("darkred", "darksalmon")) +
  scale_fill_manual(values = c("darkred", "darksalmon")) +
  theme(strip.text.x = element_text(size = 8),
        plot.title = element_text(hjust = 0.5, face="bold")) +
  xlab("Value") +
  ylab("Density") +
  guides(color = "none") +
  labs(title = "Density Comparaison of Cancer Types Gene Occurrence",
       fill = "Cancer Type")

# affichage du graphe
print(comparaison)
```

### Comparaison de Toutes les Densités

**Pour mieux visualiser les différences entre les types de cancer, représentez la comparaison de la densité de l'ensemble des types de cancer.**

::: {.callout-important appearance="simple"}
Il est important de préciser au graphe que la variable doit être considéré comme une densité à l'aide de la commande *aes(y=after_stat(density))*.
:::

```{r}
#| code-fold: true
#| code-summary: "Afficher la Solution"
#| output: true

# création de la base de données pour le graphe
data <- data.frame(type = c(rep("LumA", 50),
                            rep("LumB", 50),
                            rep("Basal", 50),
                            rep("Her2", 50),
                            rep("Normal", 50)),
                  subtype = rep(TCGA.PAM50_genefu_hg18$chr, each = 50),
                  value = c(TCGA.PAM50_genefu_hg18$LumA,
                            TCGA.PAM50_genefu_hg18$LumB,
                            TCGA.PAM50_genefu_hg18$Basal,
                            TCGA.PAM50_genefu_hg18$Her2,
                            TCGA.PAM50_genefu_hg18$Normal))

# histogramme et densité des différents types de cancer
density <- data %>%
  ggplot(aes(x = value, fill = type)) +
  geom_density(aes(y = after_stat(density), color=type), linewidth=0.5, alpha=0.4, fill=NA) +
  scale_color_manual(values = c("#69b3a2", "darkred", "darkblue", "pink", "darksalmon")) +
  scale_fill_manual(values = c("#69b3a2", "darkred", "darkblue", "pink", "darksalmon")) +
  theme(strip.text.x = element_text(size = 8),
        plot.title = element_text(hjust = 0.5, face="bold")) +
  xlab("Value") +
  ylab("Density") +
  labs(title = "Density of Cancer Types", color = "Cancer Type")

# affichage du graphe
print(density)
```

**Ajoutez les histogrammes respectifs des différents types de cancer sur le graphe précédent.**

::: {.callout-tip appearance="simple"}
## geom_histogram
Cette commande du package *ggplot2* permet de créer des histogrammes sur R. De nombreuses options sont disponibles comme color, alpha (règle la transparence du remplissage), binwidth (règle la largeur des intervalles)
et position = "identity", "dodge" (règle la position des bandes).
:::

```{r}
#| code-fold: true
#| code-summary: "Afficher la Solution"
#| output: true

# histogramme et densité des différents types de cancer
density <- data %>%
  ggplot(aes(x = value, fill = type)) +
  geom_histogram(aes(y=after_stat(density)), color = "#e9ecef", alpha = 0.3, binwidth=0.5, position = "dodge") +
  geom_density(aes(y = after_stat(density), color=type), linewidth=0.5, fill=NA) +
  scale_color_manual(values = c("#69b3a2", "darkred", "darkblue", "pink", "darksalmon")) +
  scale_fill_manual(values = c("#69b3a2", "darkred", "darkblue", "pink", "darksalmon")) +
  theme(strip.text.x = element_text(size = 8),
        plot.title = element_text(hjust = 0.5, face="bold")) +
  labs(fill = "Cancer Type") +
  xlab("") +
  ylab("Density") +
  labs(title = "Density of Cancer Type") +
  guides(color = "none")

# affichage du graphe
print(density)
```


### Fréquence des Gènes sur l'Ensemble des Chromosomes

**En appliquant les compétences acquises jusqu'ici, représentez la fréquence des gènes de *Her2* sous forme d'histogrammes et de densités pour chacun des chromosomes.**

```{r, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Afficher la Solution"
#| output: true
#| warning: false
#| message: false


# création de la base de données pour le graphe
data <- data.frame(
  type = TCGA.PAM50_genefu_hg18$chr,
  value = TCGA.PAM50_genefu_hg18$Her2
)

# histogramme de fréquence pour chaque chromosome
frequence <- data %>%
  ggplot(aes(x = value, bins=30, color = type, fill = type)) +
  geom_histogram(alpha = 0.6, position = "identity") +
  geom_density(aes(y=after_stat(ndensity)), alpha = 0.5, fill = "grey", color = "black", linewidth = 0.25) +
  scale_fill_viridis(discrete = FALSE) +
  scale_color_viridis(discrete = FALSE) +
  theme(strip.text.x = element_text(size = 8),
        plot.title = element_text(hjust = 0.5, face="bold")) +
  xlab("Chromosome") +
  ylab("Assigned Probability (%)") +
  facet_wrap(~type, scales = "fixed", nrow=3)+
  guides(color = "none", fill="none") +
  labs(title = "Frequency of Her2 Gene Occurrence on All Chromosomes")

# affichage du graphe
print(frequence)
```

**De la même façon que le graphe précédent, représentez graphiquement la fréquence des gènes de chaque type de cancer sous forme d'histogrammes et de densités pour chacun des chromosomes.**

```{r, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Afficher la Solution"
#| output: true
#| warning: false
#| error: false

# création de la base de données pour le graphe
data <- data.frame(type = TCGA.PAM50_genefu_hg18$chr,
                   subtype = c(rep("LumA", 50),
                               rep("LumB", 50),
                               rep("Basal", 50),
                               rep("Her2", 50),
                               rep("Normal", 50)),
                   value = c(TCGA.PAM50_genefu_hg18$LumA,
                             TCGA.PAM50_genefu_hg18$LumB,
                             TCGA.PAM50_genefu_hg18$Basal,
                             TCGA.PAM50_genefu_hg18$Her2,
                             TCGA.PAM50_genefu_hg18$Normal))

# histogramme de fréquence pour chaque chromosome
frequence <- data %>%
  ggplot(aes(x = value, fill = subtype, color=subtype)) +
  geom_histogram(alpha = 0.6, position = "dodge") +
  geom_density(aes(y=after_stat(ndensity), color = subtype), alpha = 0.25, fill = "grey", size = 0.25) +
  scale_color_manual(values = c("#69b3a2", "darkred", "darkblue", "pink", "darksalmon")) +
  scale_fill_manual(values = c("#69b3a2", "darkred", "darkblue", "pink", "darksalmon")) +
  theme(strip.text.x = element_text(size = 8),
        plot.title = element_text(hjust = 0.5, face="bold")) +
  xlab("Chromosome") +
  ylab("Frequency") +
  facet_wrap(~type, scales = "fixed", nrow=3)+
  guides(color = "none") +
  labs(title = "Frequency of Cancer Type Gene Occurrence on Each Chromosome",
       fill = "Cancer Type")

# affichage du graphe
print(frequence)
```

# Création de HEATMAP

Une heatmap (ou carte thermique) est une méthode de visualisation qui permet de représenter des données de grande dimension. C'est une représentation sous forme de grille de cellules colorées. Cette méthode peut être utilisée pour visualiser les observations, les corrélations ou des valeurs manquantes par exemple.

## Création d'une heatmap intéractive

L'objectif de cette partie est de réaliser des heatmap intéractives représentant les observations. Vous pourrez connaître la valeur d'une cellule en faisant simplement glisser votre souris dessus.

Pour cette première visualisation, il vous faut charger la librairie "heatmaply" et faire un choix de gradient de couleurs à l'aide des commandes suivantes :

```{r}
#| warning : FALSE
#| message : FALSE
#| results: hide
#| output: false
library(heatmaply) 
gradient_col <- ggplot2::scale_fill_gradient2(
  low = "blue", high = "red", midpoint = 0, limits = c(-8, 8))
```

Vous pouvez trouver ci-joint deux sites donnant des exemples d'utilisation et de l'aide sur la librairie heatmaply :

-   [Exemple d'utilisation de heatmaply](https://cran.r-project.org/web/packages/heatmaply/vignettes/heatmaply.html)

-   [Aide heatmaply](https://www.rdocumentation.org/packages/heatmaply/versions/1.4.2/topics/heatmaply)


Dans un premier temps, nous allons sélectionner le chromosome que l'on souhaite étudier.

Prenons ici le chromosome numéro 1.

```{r}
# on selectionne le chromosome souhaité dans notre dataframe
chr1 <- subset(gene.exp, gene.exp$chr==1) 

# on selectionne les colonnes qui nous interessent
mydata_1 <- chr1[, 3:18] 

# nom des lignes 
rownames(mydata_1) <- mydata_1[, 1] 

# on supprime la première colonne qui ne nous interesse plus
mydata_1 <- mydata_1[, -1] 
```

Création de la heatmap à l'aide de heatmaply :

```{r}
heatmaply(mydata_1, scale_fill_gradient_fun = gradient_col, 
          Colv=NA, Rowv=NA, scale='none', limits = c(-8, 8),
          xlab = "Individus",ylab = "Gènes",
          main = "Expression des gènes du chromosome 1")
```

La heatmap ci-dessus nous donne visuellement une idée de l'expression de chaque gène du chromosome 1. On observe que dans la majorité des cas le gène "CLCA2" est sur-exprimé (les cellules apparaissent très rouges), et les gènes "PDZK1" "DLANI1" sont sous-exprimés (les cellules apparaissent plutôt bleutées).

::: {.callout-note appearance="simple"}
Vous pouvez choisir d'afficher les corrélations avec la fonction `heatmaply_cor()` ou les valeurs manquantes avec la fonction `heatmaply_na()`.
:::

### A vous de jouer

En vous basant sur l'exemple ci-dessus, créez une heatmap représentant l'expression des gènes du chromosome 17.

Voici une idée du résultat que vous devez obtenir :

```{r}
#| code-fold: true
#| code-summary: "Afficher la Solution"
chr17 <- subset(gene.exp, gene.exp$chr == 17 )
mydata_17 <- chr17[,3:18] 
rownames(mydata_17) <- mydata_17[,1]
mydata_17 <- mydata_17[,-1]
heatmaply(mydata_17, scale_fill_gradient_fun = gradient_col, 
          Colv=NA, Rowv=NA, scale='none', limits = c(-7, 8),
          xlab = "Individus",ylab = "Gènes",
          main = "Expression des gènes du chromosome 17")
```


## Création d'une heatmap circulaire

L'objectif de cette seconde partie sur les heatmap est de réaliser des heatmap circulaires avec dendrogrammes.

Commencez par charger les packages nécessaires :

```{r}
#| results: hide
#| message: false
#| warning: false
#| output: false
library(circlize) 
library(ComplexHeatmap)
```

On effectue une petite modification de notre dataframe en supprimant une colonne qui ne nous sera pas utile par la suite.

```{r}
# suppression de la colonne position
gene.exp2 <- gene.exp[, -2] 
```

Pour pouvoir réaliser notre heatmap, il nous faut tout d'abord convertir notre dataframe en matrice :

```{r}
#| message : FALSE
#| warning: FALSE
mat <- as.matrix(gene.exp2, labels=TRUE) # on transforme le dataframe en matrice 

# On définit les noms des colonnes et des lignes 
row_names <- as.vector(gene.exp2$NAME)
col_names <- c("chr", "NAME", "TCGA.A2.A04W.01A", "TCGA.A2.A0D1.01A",
               "TCGA.A2.A0EQ.01A", "TCGA.A8.A081.01A", "TCGA.A8.A08J.01A",
               "TCGA.A8.A09X.01A", "TCGA.AN.A0FV.01A", "TCGA.AO.A0J2.01A",
               "TCGA.AO.A12D.01A", "TCGA.B6.A0RS.01A", "TCGA.BH.A0EE.01A", 
               "TCGA.C8.A12L.01A", "TCGA.C8.A12P.01A", "TCGA.D8.A13Z.01A", 
               "TCGA.E2.A1B0.01A")
rownames_factor <- factor(row_names)

# On met notre matrice sous format "numeric"
mat_numeric <- matrix(as.numeric(mat), ncol = ncol(mat))
rownames(mat_numeric) = row_names
colnames(mat_numeric) = col_names

# Vecteur des chromosomes :
split <- as.vector(gene.exp2$chr)
split <- factor(split)
```

::: {.callout-note appearance="simple"}
Le vecteur `split`doit contenir les différents groupes/catégories si vous souhaitez divisez votre heatmap par groupes/catégories.
:::

Création des heatmap circulaires :

-   Sur cette première heatmap, nous avons affiché tous les chromosomes ainsi que tous les gènes de la manière la plus basique possible.

```{r}
## Affichage des heatmaps
circos.clear()
circos.par(start.degree = 90, gap.degree = 3)
col_fun1 = colorRamp2(c(-6, 0, 6), c("blue", "white", "red"))

# heatmap simple 
circos.heatmap(mat_numeric[, !(colnames(mat_numeric) %in% c("chr", "NAME"))], 
               split = split, 
               col = col_fun1)

```

-   Sur cette seconde heatmap, nous avons encadré chaque chromosome et affiché son numéro.

```{r}
#| message: false
#| warning: false

# heatmap avec les chromosomes associes
circos.clear()
circos.heatmap(mat_numeric[, !(colnames(mat_numeric) %in% c("chr", "NAME"))], 
               split = split, col = col_fun1, track.height = 0.4, 
               bg.border = "green", bg.lwd = 2, bg.lty = 2, 
               show.sector.labels = TRUE)

```

-   Sur cette troisième heatmap, nous avons rajouté le nom de chaque gène.

```{r}
#| message: false
#| warning: false

# heatmap avec les chromosomes et les noms des genes
circos.clear()
circos.heatmap(mat_numeric[, !(colnames(mat_numeric) %in% c("chr", "NAME"))], 
               split = split, col = col_fun1, track.height = 0.4, 
               bg.border = "green", bg.lwd = 2, bg.lty = 2, 
               show.sector.labels = TRUE, 
               rownames.side = "outside", rownames.cex = 0.4)



```

-   Sur cette quatrième heatmap, nous avons rajouté les dendrogrammes ainsi qu'une légende de couleur.

::: {.callout-note appearance="simple"}
La méthode de clustering appliquée est `hclust` soit une méthode de classiification hierarchique, l'algorithme utilisé par défaut est celui de Ward.
:::

```{r}
#| message: false
#| warning: false

# heatmap avec les dendrogrammes 
circos.clear()
circos.heatmap(mat_numeric[, !(colnames(mat_numeric) %in% c("chr", "NAME"))], 
               split = split, col = col_fun1, track.height = 0.4, 
               bg.border = "green", bg.lwd = 2, bg.lty = 2, 
               show.sector.labels = TRUE, 
               dend.side = "outside")

lgd = Legend(title = "values", col_fun = col_fun1)
grid.draw(lgd)
```

Le nombre de chromosomes étant important, il est compliqué de voir en détail les gènes. L'exercice suivant consiste donc à sélectionner certains chromosomes et à afficher la heatmap circulaire correspondante.

::: {.callout-important appearance="simple"}
Il est important de toujours appeler la commande `circos.clear()` avant chaque nouvelle heatmap.
:::

### A vous de jouer

Sélectionnez les chromosomes 1, 3, 6, 11, 17 et 19.

```{r}
#| eval=FALSE
x <- c("XXX") # vecteur des chromosomes que l'on souhaite selectionner
data_chr <- gene.exp2[gene.exp2$chr %in% x, ] # dataframe avec nos chromosomes selectionnes


# Convertion en matrice 
mat_chr <- as.matrix(data_chr, labels=TRUE)
mat_chr_numeric <- matrix(as.numeric(mat_chr), ncol = ncol(mat_chr))

# On définit les noms des colonnes et des lignes 
row_names_chr <- as.vector(data_chr$NAME)
col_names_chr <- c("chr", "NAME", "TCGA.A2.A04W.01A", "TCGA.A2.A0D1.01A",
               "TCGA.A2.A0EQ.01A", "TCGA.A8.A081.01A", "TCGA.A8.A08J.01A",
               "TCGA.A8.A09X.01A", "TCGA.AN.A0FV.01A", "TCGA.AO.A0J2.01A",
               "TCGA.AO.A12D.01A", "TCGA.B6.A0RS.01A", "TCGA.BH.A0EE.01A", 
               "TCGA.C8.A12L.01A", "TCGA.C8.A12P.01A", "TCGA.D8.A13Z.01A", 
               "TCGA.E2.A1B0.01A")


rownames(mat_chr_numeric) = row_names_chr
colnames(mat_chr_numeric) = col_names_chr

# Vecteur des chromosomes :
split2 <- as.vector(data_chr$chr)
split2 <- factor(split2)
```

Réaliser maintenant une heatmap affichant les noms des gènes ainsi que les dendrogrammes.

```{r}
#| eval=FALSE
circos.clear()
circos.heatmap(mat_chr_numeric[, !(colnames(mat_chr_numeric) %in% c("chr", "NAME"))], 
               split = split2, col = col_fun1, track.height = 0.4, 
               bg.border = "XXX", bg.lwd = 2, bg.lty = 2, 
               show.sector.labels = TRUE, 
               dend.side = "XXX",
               rownames.side = "XXX", rownames.cex = "XXX")

lgd = Legend(title = "values", col_fun = col_fun1)
grid.draw(lgd)
```

Voici une idée du résultat que vous devez obtenir :

```{r}
#| code-fold: true
#| code-summary: "Afficher la Solution"
#| message: false
#| warning: false
x <- c(1, 3, 6, 11, 17, 19) 
data_chr <- gene.exp2[gene.exp2$chr %in% x, ] 

mat_chr <- as.matrix(data_chr, labels=TRUE)
mat_chr_numeric <- matrix(as.numeric(mat_chr), ncol = ncol(mat_chr))

row_names_chr <- as.vector(data_chr$NAME)
col_names_chr <- c("chr", "NAME", "TCGA.A2.A04W.01A", "TCGA.A2.A0D1.01A",
               "TCGA.A2.A0EQ.01A", "TCGA.A8.A081.01A", "TCGA.A8.A08J.01A",
               "TCGA.A8.A09X.01A", "TCGA.AN.A0FV.01A", "TCGA.AO.A0J2.01A",
               "TCGA.AO.A12D.01A", "TCGA.B6.A0RS.01A", "TCGA.BH.A0EE.01A", 
               "TCGA.C8.A12L.01A", "TCGA.C8.A12P.01A", "TCGA.D8.A13Z.01A", 
               "TCGA.E2.A1B0.01A")


rownames(mat_chr_numeric) = row_names_chr
colnames(mat_chr_numeric) = col_names_chr

split2 <- as.vector(data_chr$chr)
split2 <- factor(split2)

circos.clear()
circos.heatmap(mat_chr_numeric[, !(colnames(mat_chr_numeric) %in% c("chr", "NAME"))], 
               split = split2, col = col_fun1, track.height = 0.4, 
               bg.border = "green", bg.lwd = 2, bg.lty = 2, 
               show.sector.labels = TRUE, dend.side = "outside",
               rownames.side = "inside", rownames.cex = 0.35)
lgd = Legend(title = "values", col_fun = col_fun1)
grid.draw(lgd)

```

Vous pouvez consulter le lien suivant si vous souhaitez en apprendre plus sur les heatmap circulaires : [heatmap circulaire](https://jokergoo.github.io/circlize_book/book/circos-heatmap.html)

# Visualisation avec Circos

A présent, nous allons réaliser une visualisation circulaire à l'aide du package `omicCircos` et de la fonction`circos`.

Vous pouvez trouver de l'aide au package OmicCircos aux liens suivants :

-   [Aide du package](https://bioc.ism.ac.jp/packages/3.7/bioc/manuals/OmicCircos/man/OmicCircos.pdf)

-   [Exemple d'utilisation avec code](https://bioconductor.org/packages/devel/bioc/vignettes/OmicCircos/inst/doc/OmicCircos_vignette.pdf)

-   [Zoom sur des secteurs](https://jokergoo.github.io/circlize_book/book/advanced-layout.html#zooming-of-sectors)

```{r, circos}


colors = rainbow(10, alpha = 0.5)   # choix des couleurs 

# Si vous souhaitez enregistrer votre image sous forme de pdf 
#pdf("visucomp_histo.pdf", 8,8) # nom de l'image
#par(mar = c(2, 2, 2, 2))  # definition de la fenetre graphique
 
plot(c(1,800), c(1,800), type = "n", axes = FALSE, xlab = "", ylab = "", main = "") 
zoom = c(1, 22, 939245.5, 154143883, 0, 180)

######  Moitié droite du cercle ##########

# mettre les chromosomes et l'emplacement des genes
circos(type = "chr", R = 400, cir = "hg18", W = 4, 
       print.chr.lab = TRUE, scale = TRUE, zoom = zoom)


# creation de la heatmap
circos(type = "heatmap2", R = 300, cir = "hg18", W = 100, 
       mapping = gene.exp, col.v = 4, cluster = FALSE, 
       col.bar = TRUE, lwd = 0.01, zoom = zoom)

# nombre de copies (gain_rouge, perte_bleu)
circos(type = "ml3", R = 220, cir = "hg18", W = 80, mapping = cnv,
       col.v = 4, B = FALSE, lwd = 1, cutoff = 0,
       zoom = zoom)

# creation de l'histogramme
circos(type = "h", R = 140, cir = "hg18", W = 80, mapping = cnv,
       col.v = 4, B = TRUE, lwd = 1, col = colors[1],
       zoom = zoom)

# lien entre certains genes
circos(type = "link", R = 130, cir = "hg18", W = 10, 
       mapping = TCGA.BC.fus, lwd = 2, zoom = zoom)

# Mise en valeur des chromosomes 11 et 17
the.col1 = rainbow(10, alpha = 0.5)[1]
highlight = c(140, 400, 11, 282412.5, 11, 133770314.5, the.col1, the.col1)

circos(type = "hl", R = 110, cir = "hg18", W = 40, 
       mapping = highlight, lwd = 2, zoom = zoom)

the.col2 = rainbow(10, alpha = 0.5)[6];
highlight = c(140, 400, 17, 739525, 17, 78385909, the.col2, the.col2)

circos(type = "hl", R = 110, cir = "hg18", W = 40, 
       mapping = highlight, lwd = 2, zoom = zoom)

highlight.link1 = c(400, 400, 140, 376.8544, 384.0021,
                    450, 540.5)

circos(type = "highlight.link", cir = "hg18", 
       mapping = highlight.link1, col = the.col1, lwd = 1)

highlight.link2 = c(400, 400, 140, 419.1154, 423.3032,
                    543, 627)

circos(type = "highlight.link", cir = "hg18", 
       mapping = highlight.link2, col = the.col2, lwd = 1)


####### Moitié gauche du cercle #######

# Chromosome 11 
zoom = c(11, 11, 282412.5, 133770314.5, 180, 270)

circos(type = "chr",R = 400, cir = "hg18", W = 4, print.chr.lab = TRUE, 
       scale = TRUE, zoom = zoom)

circos(type = "heatmap2", R = 300, cir = "hg18", W = 100, 
       mapping = gene.exp, col.v = 4, cluster = FALSE, lwd = 0.01,
       zoom = zoom)

circos(type = "ml3", R = 220, cir = "hg18", W = 80, mapping = cnv,
       col.v = 4, B = FALSE, lwd = 1, cutoff = 0,
       zoom = zoom)

circos(type = "h", R = 140, cir = "hg18", W = 80, mapping = cnv,
       col.v = 4, B = TRUE, lwd = 1, col = colors[1],
       zoom = zoom)




# Chromosome 17 
zoom = c(17, 17, 739525, 78385909, 274, 356)

circos(type = "chr", R = 400, cir = "hg18", W = 4, print.chr.lab = TRUE, 
       scale = TRUE, zoom = zoom)

circos(type = "heatmap2", R = 300, cir = "hg18", W = 100, 
       mapping = gene.exp, col.v = 4,  cluster = FALSE, lwd = 0.01,
       zoom = zoom)

circos(type = "ml3", R = 220, cir = "hg18", W = 80, mapping = cnv,
       col.v = 4,  B = FALSE, lwd = 1, cutoff = 0,
       zoom = zoom)

circos(type = "h", R = 140, cir = "hg18", W = 80, mapping = cnv,
       col.v = 4,  B = TRUE, lwd = 1, col = colors[1],
       zoom = zoom)





```

De l'extérieur vers l'intérieur, vous pouvez trouver :

-   le numéro du chromosome et la position des gènes

-   une heatmap de l'expression des gènes

-   le nombre de copies de chaque gènes par rapport à la normale (rouge : gain, bleu : perte)

-   des histogrammes pour observer la dispersion de la loi de distribution

-   des liaisons entre les protéines de fusion (tracées avec l'algorithme de courbe de Bézier)





# Lexique

* *hg18* : La représentation du génome humain a connu plusieurs versions avant d'aboutir à la représentation la plus optimale. La version 18 s'agit de la version avant dernière.

* Her2 : Une protéine naturellement présente dans l’organisme. Il s’agit d’un récepteur transmembranaire impliqué dans la régulation de la prolifération cellulaire.

* LumA : Le cancer du sein Luminal A est l'un des sous-types luminaux et est généralement associé à des caractéristiques moins agressives par rapport à Luminal B.

* LumB : Associé à un grade plus élevé, des taux de prolifération accrus, et un pronostic global plus défavorable.

* Basal : Un sous-type du cancer du sein négatif pour les récepteurs d'oestrogène (ER), les récepteurs de progestérone (PR) et le récepteur 2 du facteur de croissance épidermique humain (HER2). On le désigne souvent comme un cancer du sein triple négatif (TNBC).

* FDR (First Division Restitution) : Réfère à l'évènement où l'une des cellules filles produites lors de la première division méiotique conserve les deux chromatides d'un chromosome, sans subir la séparation normale en deux cellules distinctes. Cela aboutit à un gamète avec un ensemble complet de chromosomes, plutôt que la moitié attendue.

* Bonferroni : Une correction statistique.




